## 銀行システム（コア機能）要件定義書 (アクターモデル版)

### 1. はじめに

#### 1.1. 目的
本文書は、アプリケーション開発の学習を目的として、銀行システムのコア機能である「送金」を模倣したアプリケーションを開発する際の要件を定義するものです。特に、送金処理の技術的な仕様を明確にすることを目的とします。

#### 1.2. 範囲
本文書の範囲は、以下のエンティティおよび機能に限定します。
* **エンティティ:** 口座 (Account)、取引履歴 (Transaction)
* **機能:** 送金 (Transfer)

UI（ユーザーインターフェース）や認証機能、利息計算などの高度な機能は範囲外とします。

#### 1.3. 用語定義
| 用語 | 説明 |
| :--- | :--- |
| **エンティティ** | システムが管理するデータのまとまり。データベースのテーブルに相当します。 |
| **トランザクション** | 関連する一連の処理を一つの処理単位としてまとめたもの。全て成功するか、全て失敗するかのどちらかの結果しか許容しません。 |
| **ACID特性** | データベースのトランザクション処理に求められる4つの性質（原子性、一貫性、独立性、永続性）のことです。 |
| **ロールバック** | トランザクション処理中にエラーが発生した場合に、処理開始前の状態にデータを復元することです。 |

---

### 2. アーキテクチャ概要

本システムは、並行処理と状態管理に優れた**アクターモデル**を設計の基本思想として採用します。

  * **口座のモデル化:** 個々の銀行口座は、それぞれが独立した\*\*「アクター (Actor)」\*\*として表現されます。各口座アクターは自身の状態（残高など）をカプセル化し、外部とは非同期のメッセージパッシングによってのみ通信します。
  * **処理の実行:** 送金のような複数のアクターにまたがる処理は、アクター間のメッセージの連鎖によって実現されます。

---

### 3. 用語定義

| 用語 | 説明 |
| :--- | :--- |
| **アクター** | 状態(State)と振る舞い(Behavior)を持つ計算の単位。自身のメールボックスに届いたメッセージを一つずつ順に処理します。 |
| **メッセージ** | アクター間でやり取りされる不変のデータオブジェクト。処理の依頼や結果通知に使われます。 |
| **メールボックス** | アクターが受信したメッセージを一時的に保持するキュー。 |
| **Sagaパターン** | 複数のサービス（アクター）にまたがる一連の処理の整合性を保つためのデザインパターン。各処理と、それを取り消すための**補償処理**をセットで定義します。 |
| **結果整合性** | システム全体の状態が、最終的には矛盾のない状態に落ち着くという性質。アクターモデルのような分散システムで採用される整合性モデルです。 |
| **永続化** | アクターのメモリ上の状態を、システムが停止しても失われないようにストレージに保存することです。 |

---

### 4. アクター定義

システムの基礎となるアクターの設計を以下のように定義します。

#### 4.1. 口座アクター (AccountActor)

顧客の口座情報を管理し、残高に関する操作を実行します。システム内に口座の数だけ生成されます。

  * **状態 (State):**

      * `account_id` (文字列): アクターを一意に識別するID
      * `account_number` (文字列): 利用者が使用する口座番号
      * `holder_name` (文字列): 口座名義人名
      * `balance` (数値型): 現在の残高

  * **受信メッセージ (Messages):**

      * `Withdraw(amount, transaction_id, reply_to)`: 出金依頼
      * `Deposit(amount, transaction_id, reply_to)`: 入金依頼
      * `GetBalance(reply_to)`: 残高照会依頼

  * **振る舞い (Behavior):**

      * メッセージをメールボックスから一つずつ取り出し処理します。これにより、**単一アクター内での状態変更は常に同期的**に行われ、ロックなしでデータの競合を防ぎます。

---

### 5. 機能要件

#### 5.1. 送金機能 (FR-001)

##### 5.1.1. 概要

送金処理の原子性を担保するために、**Sagaパターン**を用いて実装します。処理全体を監督する**コーディネーターアクター (TransferCoordinator)** が、各口座アクターへのメッセージ送信を管理します。

##### 5.1.2. 入力

(RDB版と同様)

##### 5.1.3. 処理フロー (Sagaパターンに基づく)

https://microservices.io/patterns/data/saga.html
*Sagaパターンによる処理の流れのイメージ*

1.  **送金リクエストの受信**

      * クライアントは、送金元・送金先口座番号、金額を含む `TransferRequest` メッセージを `TransferCoordinator` アクターに送信します。

2.  **Sagaの開始**

      * `TransferCoordinator` は一意の取引IDを生成し、Sagaトランザクションを開始します。

3.  **出金処理の実行**

      * `TransferCoordinator` は、送金元 `AccountActor` に対して `Withdraw` メッセージを送信します。
      * 送金元 `AccountActor` はメッセージを受信し、以下の処理を実行します。
          * 残高が送金金額以上であることを確認します。
          * **成功の場合:** 残高を減算し、`WithdrawSuccessful` メッセージを `TransferCoordinator` に返信します。
          * **失敗の場合（残高不足など）:** `WithdrawFailed` メッセージを `TransferCoordinator` に返信します。この場合、Sagaは失敗となり、ここで処理を終了します。

4.  **入金処理の実行**

      * `TransferCoordinator` が `WithdrawSuccessful` メッセージを受け取ると、次ステップとして送金先 `AccountActor` に `Deposit` メッセージを送信します。
      * 送金先 `AccountActor` はメッセージを受信し、残高を加算して `DepositSuccessful` メッセージを `TransferCoordinator` に返信します。
          * (もし送金先口座が存在しない、または何らかの理由で入金が失敗した場合は `DepositFailed` を返信します)

5.  **Sagaの完了**

      * `TransferCoordinator` が `DepositSuccessful` メッセージを受け取ると、Sagaトランザクションは成功とみなし、クライアントに成功を通知します。

6.  **【重要】補償処理 (失敗ケース)**

      * もし、ステップ4の入金処理で `DepositFailed` を受け取った場合（例: 送金先口座が凍結された直後など）、`TransferCoordinator` は**補償トランザクション**を開始します。
      * `TransferCoordinator` は、すでに出金が完了している送金元 `AccountActor` に対して、出金を取り消すための `Deposit` メッセージ（送金額を元に戻すための入金指示）を送信します。
      * これにより、**送金処理全体が実行されなかったのと同じ状態**に戻し、一貫性を保ちます。

##### 5.1.4. 出力

* **成功時:** 取引が正常に完了したことを示すメッセージ、または取引IDを返します。
* **失敗時:** バリデーションエラーや処理中のエラーに応じたエラーメッセージ（例: 「残高が不足しています」、「送金先口座が存在しません」）を返します。

-----

### 6\. 非機能要件

#### 6.1. 信頼性

  * **原子性の担保:** 送金処理の原子性は、ACIDトランザクションではなく **Sagaパターン** と**補償処理**によって保証されます。
  * **整合性モデル:** 強整合性ではなく、**結果整合性**を許容します。送金処理の途中のごくわずかな時間、システム全体の総資産額が一時的に合わない状態が存在し得ますが、最終的には必ず正しい状態に収束します。
  * **永続化 (Persistence):** 💣
      * アクターの状態は通常メモリ上にあるため、システム障害時に状態が失われないよう、**アクターの状態を永続化**する必要があります。
      * 状態が変更されるたびにその内容（イベント）をジャーナルに記録する**イベントソーシング**方式、または定期的に状態全体を保存する**スナップショット**方式などを採用します。

#### 6.2. 排他制御

  * RDBのようなロックによる排他制御は行いません。
  * 各 `AccountActor` は、自身のメールボックスに届いたメッセージを**シングルスレッドで一つずつ処理**するため、同一口座に対する複数の操作が同時に実行されることはなく、データの競合は原理的に発生しません。